## 引言
你还在使用 `div` 这个一点也不现代化的标签么？在 `HTML5` 的语义化的标签中（虽然不够）穿插着 `div`，你说多别扭啊。

```
<div class="chat">
  <article class="chat-item" datetime="2016-01-23T12:02">
    <div class="chat-content">
        <img class="avatar" src="..." alt="Judy">
        <p class="content">How are you doing there?</p>
    </div>
    <div class="chat-action">
        <div class="chat-reply"><i class="icon-reply"></i> Reply</div>
        ...
    </div>
  </article>
  <article class="chat-item">...</article>
</div>
```

看着这种代码是不是很糟糕，更何况这只会是我们网页中的一部分。

### 时髦的标记
如果，我们的标记不是像上面的那样，而是像这下面这样，那会怎么样？
```
<chat-dialog>
    <chat-item datetime="2016-01-23T12:02">
        <chat-content from="Judy" profile="...">
            <p>How are you doing there?</p>
        </chat-content>
        <chat-actionbar>
            <chat-action><icon icon="Reply"></icon>Reply</chat-action>
        </chat-actionbar>
    </chat-item>
</chat-dialog>
```

这样看起来是不是舒服多了？它**容易理解**、**容易维护**，比起用 `div` 的标签好得不知道哪里去了。

这个就是 HTML5 给我们带来的工具之一—— `自定义元素标签`，并且，随着 HTML5 技术的不断成熟，自定义元素标签的应用是越来越广泛了。

## 那就让我们开始吧
### 注册新的元素标签
```
var xFoo = document.registerElement('X-Foo')
document.body.appendChild(new xFoo())
```
这里的 `document.registerElement` 的第一个参数时是元素标签名，它**必须包含一个连字符(-)**，也就是说 `<hello-world>` `<my-heart>`  这种标签都是被接受的，而 `<hello_world>` `<myheart>` 是不符合标准的。
这个限定使解析器能很容易地区分自定义元素和 HTML 规范定义的元素，同时确保了 HTML 增加新标签时的向前兼容。

第二个参数呢是 *（可选的）* 对象，用于描述元素的 prototype，并且默认继承 `HTMLElement`。
因此上述的代码还能如此书写：

```
var xFoo = document.registerElement('X-Foo', {
    prototype: Object.create(HTMLElement.prototype)
})
```

运用这个性质我们还可以制造一个 `MegaInput`，`MegeButton` 等……

```
var megaInput = document.registerElement('mega-input', {
    prototype: Object.create(HTMLInputElement.prototype)
})
```

这类自定义元素被称为类型扩展自定义元素。它们以继承某个特定 `HTMLElement` 的方式表达了“元素 X 是一个 Y”。如下所示：

```
<input is="mega-input">
```

## 实例化元素
既然创建了元素了，那么我们就可以使用了。它和我们其他的规范中的元素一样，都可以通过 `HTML` 或者 `JavaScript` 的方式实例化。

### 实例化自定义元素
你可以在 **HTML** 中添加如下代码：
```
<X-Foo></X-Foo>
```

或者在 **JavaScript** 使用如下代码：
```
var XFoo = document.createElement('X-Foo');
document.body.appendChild(XFoo);
```

或者用 **new** 的方式：
```
var XFoo = new xFoo();
document.body.appendChild(XFoo);
```

### 实例化扩展元素
实际上，实例化扩展元素和实例化自定义元素是差不了多少的。

你可以在 **HTML** 中添加如下代码：
```
<input is="mega-input"></input>
```

或者在 **JavaScript** 使用如下代码：
```
var input = document.createElement('input', 'mega-input');
document.body.appendChild(input);
```

或者用 **new** 的方式：
```
var input = new megaInput();
document.body.appendChild(input);
```

现在，我们意见了解了如何创建**自定义元素**和**扩展元素**，接下来我们就要玩点高级的啦，让它与 `JavaScript` 相结合。

## 添加 JavaScript 属性与方法
自定义元素标签强大的地方不仅仅时提供了创建新的标签，而是能给这一类的元素添加属性与方法，也就是公共API。
这个时候，我们就要用到我们上文提到的 `document.registerElement` 的第二个参数了。

这里有一个完整的示范：
```
var xFoo = document.registerElement('X-Foo', {
  prototype: Object.create(HTMLElement.prototype, {
    bar: {
      get: function() { return 'foobar'; }
    },
    foo: {
      value: function() {
        alert('foo() called');
      }
    }
  })
})

var XFoo = document.createElement('X-Foo')
document.body.appendChild(XFoo)
```

### 生命周期回调方法
元素可以定义特殊的方法，在它生存期内关键的时间点所执行的方法。这些方法各自有特定的名称和用途，它们的统称就是**生命周期回调**：

| 回调名称 | 调用时间 |
|----------|---------:|
| createdCallback  |        创建元素实例 |
| attachedCallback |   向 *DOM* 插入实例 |
| detachedCallback | 从 *DOM* 中移除实例 |
| attributeChangedCallback *(attrName, oldVal, newVal)* | 添加，移除，或修改一个属性 |

**示例**：为 <X-Foo> 定义 createdCallback()
```
var xFooPrototype = Object.create(HTMLElement.prototype);

xFooPrototype.createdCallback = function() {
    alert('Hello, World!')

    this.classList.add('x-foo')
    this.innerHTML = 'Hello, World'
}

var xFoo = document.registerElement('X-Foo', {prototype: xFooPrototype});
```

这些**生命周期回调**都是可选的，你可以使用他们进行复杂的操作。特别是在元素笨重的情况下，这个回调特别有用。