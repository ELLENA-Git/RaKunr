> 本文章乃 Rakume 这个渣渣，在自己的理解基础上翻译的，与原文略有出入。还请大家随意吐槽，这样才能有所进步，感谢。
>
> Original Post：[How to animate box-shadow](http://tobiasahlin.com/blog/how-to-animate-box-shadow/)



* * * 

我们该如何避免重绘而又能保证 `box-shadow` 的动画能正常表现，并且不影响到你页面的效果呢？这是一个很好的问题，实际上如果直接得对 `box-shadow` 进行操作的话，我们的目标是永远不能达成的。除非客户的配置够好，可使我们要的就是在配置不好的电脑上流畅运行，所以那自然只能另想办法了。

这里有一个即简单又优雅的能达到类似效果的方法，它能保证动画以 60 FPS 的帧率运行：那就是，操作伪元素的 `opacity`，以实现 `box-shadow` 的动画效果。



## 演示

![实际上的效果的录像（Recording of box-shadow demo in action）](//c.hime.io/images/QOBw.gif)

[点击这里查看演示](http://tobiasahlin.com/demo/animate-box-shadow/)并且对比一下我们所要讲的两种实现 `box-shadow` 动画的方法的区别。我想，在你的电脑上这倆在表现上是没有区别的，那就恭喜了，因为这说明了你电脑的配置足够好。其中的不同点是，我们如何实现阴影的动画。

容器左边的，我们直接操作 `box-shadow` 来控制动画；而容器右边，则是使用了伪元素 `::after` 的方案。

如果你打开你的开发者工具，接着将鼠标置悬在这些元素上，你会发现类似这个下图的情况（绿条的高低为重绘所用的时间，越少越好）：

![两种不同动画的实现效率](https://c.hime.io/images/j0l4.png)

这张图，很明显地揭示了方案一方案二的差异性，同时方案二的性能十分之高。

但，为什么针对伪类的动画会更加高效呢？因为这里的[一些 CSS 属性](http://csstriggers.com/)在动画时是可以不需一直触发每帧的重绘，就如 `opacity` 与 `transform`。我们可以通过改变它俩，从而达到减少重绘的数量与时间长短的目的。

这里是两种方法的**具体的区别**，抛开布局上来讲：


```CSS
/* 慢的那种方法 */
.make-it-slow {
  box-shadow: 0 1px 2px rgba(0,0,0,0.15);
  transition: box-shadow 0.3s ease-in-out:
}

/* 划过后从无到有的阴影 */
.make-it-slow:hover {
  box-shadow: 0 5px 15px rgba(0,0,0,0.3);
}

/* 快的那种方法 */
.make-it-fast {
  box-shadow: 0 1px 2px rgba(0,0,0,0.15);
}

/* 提前渲染好阴影，不过隐藏着的 */
.make-it-fast::after {
  box-shadow: 0 5px 15px rgba(0,0,0,0.3);
  opacity: 0;
  transition: opacity 0.3s ease-in-out:
}

/* 划过后阴影显露出来 */
.make-it-fast:hover::after {
  opacity: 1;
}
```

从示例中，我们可以看到，更有效率的那一种方法中，有两层：一层给卡片，另外一层是阴影的，并且，动画只改变阴影的 `opacity`。



## 分解

有了基本原理，那就让我们来看看如何创建的[3D 效果卡片](http://tobiasahlin.com/demo/animate-box-shadow/)。第一步，就是需要给伪元素添加阴影，就像我盟在上面做的一样。这一次，我们来写出所有的代码，包括布局：

```
/* HTML 中你只需要 <div class="box"></div> */

/* 创建一个白色的卡片，然后给它添加默认的阴影状态 */
.box {
  position: relative;
  display: inline-block;
  width: 100px;
  height: 100px;
  border-radius: 5px;
  background-color: #fff;
  box-shadow: 0 1px 2px rgba(0,0,0,0.15);
  transition: all 0.3s ease-in-out;
}

/* 创建隐藏的伪元素 */
/* 包括阴影的最后状态 */
.box::after {
  content: '';
  position: absolute;
  z-index: -1;
  width: 100%;
  height: 100%;
  opacity: 0;
  border-radius: 5px;
  box-shadow: 0 5px 15px rgba(0,0,0,0.3);
  transition: opacity 0.3s ease-in-out;
}
```

需要注意的是，我们给 `.box` 和 `.box::after` 添加了一个 `transition`，并且当这些元素开始播放动画的时候，这些属性会发生改变：`.box` 的 `transform` 和 `.box::after` 的 `opacity`。

这三个样式给了我们一个奇妙的 `box-shadow`。更强大的是，`.box::after` 在默认时是完全隐藏的，同时它并不会与卡片相互作用。

<div id="box-1"></div>
<style type="text/css">
#box-1 { position: relative; display: block; margin: 0 auto; width: 100px; height: 100px; border-radius: 5px; background-color: #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.15); transition: all 0.3s ease-in-out; }
#box-1::after { content: ''; position: absolute; z-index: -1; width: 100%; height: 100%; opacity: 0; border-radius: 5px; box-shadow: 0 5px 15px rgba(0,0,0,0.3); transition: opacity 0.3s ease-in-out; }
</style>

为了实现与[演示](http://tobiasahlin.com/demo/animate-box-shadow/)中一样的效果，现在我们需要的只是，当 `.box` 被划过时缩放它，并且渐入阴影。


```
/* 缩放卡片 */
.box:hover {
  transform: scale(1.2, 1.2);
}

/* 伪元素的阴影渐入 */
.box:hover::after {
  opacity: 1;
}
```

好了！就到这了！我们赶紧来看看效果吧。

<div id="box-2"></div>
<style type="text/css">
#box-2 { position: relative; display: block; margin: 0 auto; width: 100px; height: 100px; border-radius: 5px; background-color: #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.15); transition: all 0.3s ease-in-out; }
#box-2::after { content: ''; position: absolute; z-index: -1; width: 100%; height: 100%; opacity: 0; border-radius: 5px; box-shadow: 0 5px 15px rgba(0,0,0,0.3); transition: opacity 0.3s ease-in-out; }
#box-2:hover { transform: scale(1.2, 1.2); }
#box-2:hover::after { opacity: 1; }
</style>

好了，为了总结，这里是完整的 CSS 代码，自带~~特效~~，并且有着自定义的动画曲线。

```
.box {
  position: relative;
  display: inline-block;
  width: 100px;
  height: 100px;
  background-color: #fff;
  border-radius: 5px;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
  border-radius: 5px;
  -webkit-transition: all 0.6s cubic-bezier(0.165, 0.84, 0.44, 1);
  transition: all 0.6s cubic-bezier(0.165, 0.84, 0.44, 1);
}

.box::after {
  content: "";
  border-radius: 5px;
  position: absolute;
  z-index: -1;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
  opacity: 0;
  -webkit-transition: all 0.6s cubic-bezier(0.165, 0.84, 0.44, 1);
  transition: all 0.6s cubic-bezier(0.165, 0.84, 0.44, 1);
}

.box:hover {
  -webkit-transform: scale(1.25, 1.25);
  transform: scale(1.25, 1.25);
}

.box:hover::after {
    opacity: 1;
}
```

能确定得是，我们能用一句简短的话来实现的 `box-shadow` 的动画，我们现在却只是为了高效，却选用了一种许多的 CSS 代码。为什么呢，兄弟？

即使你的桌面系统能够很好的处理 `box-shadow` 的动画，但是你的手机却可能不行，甚至你的电脑在一些复杂的动画或者繁多的动画之下也会显得吃力，所以我们应该采用更高效的方式来完成一件事件。

只要使用最少的重绘来达到动画流畅，那么用户体验一定会上升许多，从而使客流不断地形成一个良性循环。